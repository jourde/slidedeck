<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Markdown Slide Deck</title>
  <style>
    :root {
      --bg-a: #ffffff;
      --bg-b: #f2f5fa;
      --text: #1e2430;
      --muted: #4f5a6d;
      --accent: #1c7ed6;
      --accent-hover: #176ab5;
      --focus-ring: #0f62b2;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      color: var(--text);
      font-family: "Avenir Next", "Segoe UI", "Helvetica Neue", sans-serif;
      background: radial-gradient(circle at top left, var(--bg-a) 0%, var(--bg-b) 100%);
      overflow: hidden;
    }

    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .skip-link {
      position: fixed;
      top: 8px;
      left: 8px;
      z-index: 200;
      padding: 8px 10px;
      border-radius: 8px;
      background: #ffffff;
      color: #10375f;
      border: 2px solid #9fc3e8;
      transform: translateY(-160%);
      transition: transform 120ms ease;
      text-decoration: none;
      font-weight: 700;
    }

    .skip-link:focus-visible {
      transform: translateY(0);
      outline: 3px solid var(--focus-ring);
      outline-offset: 2px;
    }

    .app {
      height: 100vh;
      width: 100%;
      padding: clamp(20px, 4vw, 44px);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0;
    }

    .upload-cta {
      border: 0;
      border-radius: 999px;
      background: var(--accent);
      color: #fff;
      padding: 11px 18px;
      font-size: 0.95rem;
      font-weight: 700;
      line-height: 1;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      box-shadow: 0 10px 20px rgba(28, 126, 214, 0.22);
      transition: background 140ms ease, transform 140ms ease;
    }

    .upload-cta:hover {
      background: var(--accent-hover);
      transform: translateY(-1px);
    }

    .upload-cta:focus-visible {
      outline: 3px solid var(--focus-ring);
      outline-offset: 2px;
    }

    .upload-cta svg {
      width: 18px;
      height: 18px;
      fill: currentColor;
    }

    .slide {
      width: min(1280px, 100%);
      flex: 1;
      min-height: 0;
      overflow: auto;
      padding: 0;
      line-height: 1.5;
      font-size: clamp(1rem, 1.18vw, 1.4rem);
    }

    .slide-center {
      min-height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: clamp(10px, 2vw, 24px);
    }

    .slide.is-tall .slide-center {
      align-items: flex-start;
    }

    .slide-content {
      width: min(1100px, 100%);
    }

    .train-map {
      --station-size: 22px;
      --station-center-y: 22px;
      width: min(1100px, 100%);
      height: 66px;
      display: none;
      align-items: center;
      justify-content: center;
      position: relative;
      padding: 12px 22px 8px;
    }

    .app.train-visible .train-map {
      display: flex;
    }

    .train-track {
      position: absolute;
      left: 24px;
      right: 24px;
      height: 4px;
      background: #d3dbe8;
      border-radius: 999px;
      top: var(--station-center-y);
      transform: translateY(-50%);
    }

    .train-progress {
      position: absolute;
      left: 24px;
      height: 4px;
      background: #6eaee8;
      border-radius: 999px;
      top: var(--station-center-y);
      transform: translateY(-50%);
      pointer-events: none;
      z-index: 0;
    }

    .station-list {
      position: absolute;
      left: 24px;
      right: 24px;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      top: calc(var(--station-center-y) - (var(--station-size) / 2));
      z-index: 1;
    }

    .station-step {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 7px;
      min-width: 18px;
    }

    .station {
      width: var(--station-size);
      height: var(--station-size);
      border-radius: 999px;
      border: 2px solid #c0cbdd;
      background: #fff;
      cursor: pointer;
      position: relative;
      transition: transform 120ms ease, border-color 120ms ease, background 120ms ease, box-shadow 120ms ease;
    }

    .station:focus-visible {
      outline: 3px solid var(--focus-ring);
      outline-offset: 2px;
    }

    .station::after {
      content: "";
      position: absolute;
      width: 4px;
      height: 4px;
      border-radius: 999px;
      background: #b9c6da;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }

    .station:hover {
      transform: translateY(-1px);
      border-color: #8ea3c0;
    }

    .station.past {
      border-color: #6eaee8;
      background: #e6f2ff;
    }

    .station.past::after {
      background: #6eaee8;
    }

    .station.active {
      border-color: var(--accent);
      background: var(--accent);
      box-shadow: 0 0 0 4px rgba(28, 126, 214, 0.17);
      transform: translateY(-1px);
    }

    .station.active::after {
      background: #ffffff;
    }

    .station-num {
      font-size: 10px;
      line-height: 1;
      color: #667287;
      font-weight: 600;
      user-select: none;
    }

    .map-toggle {
      position: fixed;
      right: 16px;
      bottom: 14px;
      border: 0;
      border-radius: 999px;
      background: #ffffff;
      color: #2e3c54;
      width: 44px;
      height: 44px;
      padding: 0;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 8px 20px rgba(21, 34, 54, 0.14);
      transition: transform 120ms ease, box-shadow 120ms ease;
    }

    .map-toggle .material-symbols-outlined {
      font-size: 24px;
      line-height: 1;
    }

    .map-toggle:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 10px 22px rgba(21, 34, 54, 0.18);
    }

    .map-toggle:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .map-toggle:focus-visible {
      outline: 3px solid var(--focus-ring);
      outline-offset: 2px;
    }

    .search-toggle {
      position: fixed;
      right: 16px;
      bottom: 66px;
      border: 0;
      border-radius: 999px;
      background: #ffffff;
      color: #2e3c54;
      width: 44px;
      height: 44px;
      padding: 0;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 8px 20px rgba(21, 34, 54, 0.14);
      transition: transform 120ms ease, box-shadow 120ms ease;
    }

    .search-toggle:hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 22px rgba(21, 34, 54, 0.18);
    }

    .search-toggle:focus-visible {
      outline: 3px solid var(--focus-ring);
      outline-offset: 2px;
    }

    .search-toggle .material-symbols-outlined {
      font-size: 24px;
      line-height: 1;
    }

    .arrows-toggle {
      position: fixed;
      right: 16px;
      bottom: 118px;
      border: 0;
      border-radius: 999px;
      background: #ffffff;
      color: #2e3c54;
      width: 44px;
      height: 44px;
      padding: 0;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 8px 20px rgba(21, 34, 54, 0.14);
      transition: transform 120ms ease, box-shadow 120ms ease;
    }

    .arrows-toggle:hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 22px rgba(21, 34, 54, 0.18);
    }

    .arrows-toggle:focus-visible {
      outline: 3px solid var(--focus-ring);
      outline-offset: 2px;
    }

    .arrows-toggle .material-symbols-outlined {
      font-size: 24px;
      line-height: 1;
    }

    .nav-arrow {
      position: fixed;
      top: 50%;
      transform: translateY(-50%);
      border: 0;
      border-radius: 999px;
      width: 46px;
      height: 46px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      background: rgba(255, 255, 255, 0.95);
      color: #2b3a52;
      box-shadow: 0 8px 20px rgba(21, 34, 54, 0.16);
      cursor: pointer;
      z-index: 50;
    }

    .nav-arrow[hidden] {
      display: none;
    }

    .nav-arrow.left {
      left: 14px;
    }

    .nav-arrow.right {
      right: 14px;
    }

    .nav-arrow:focus-visible {
      outline: 3px solid var(--focus-ring);
      outline-offset: 2px;
    }

    .nav-arrow .material-symbols-outlined {
      font-size: 24px;
      line-height: 1;
    }

    .nav-arrow:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }

    .search-panel {
      position: fixed;
      right: 68px;
      bottom: 66px;
      z-index: 60;
      display: flex;
      align-items: center;
      gap: 6px;
      background: #ffffff;
      border: 1px solid #d5deeb;
      border-radius: 12px;
      box-shadow: 0 10px 24px rgba(21, 34, 54, 0.16);
      padding: 8px;
      max-width: min(520px, calc(100vw - 84px));
    }

    .search-panel[hidden] {
      display: none;
    }

    .search-input {
      width: min(260px, 52vw);
      border: 1px solid #c6d2e4;
      border-radius: 8px;
      padding: 8px 9px;
      font-size: 0.9rem;
      color: #1f2b3f;
    }

    .search-input:focus-visible {
      outline: 3px solid var(--focus-ring);
      outline-offset: 1px;
      border-color: #7ea9d6;
    }

    .search-count {
      min-width: 58px;
      text-align: center;
      font-size: 0.78rem;
      color: #49586f;
      font-weight: 600;
      padding: 0 4px;
    }

    .search-nav {
      width: 34px;
      height: 34px;
      border-radius: 8px;
      border: 1px solid #c9d4e5;
      background: #fff;
      color: #2f3d55;
      cursor: pointer;
      font-size: 1rem;
      line-height: 1;
    }

    .search-nav:focus-visible {
      outline: 3px solid var(--focus-ring);
      outline-offset: 1px;
    }

    .search-close {
      width: 34px;
      height: 34px;
      border-radius: 8px;
      border: 1px solid #c9d4e5;
      background: #fff;
      color: #2f3d55;
      cursor: pointer;
      font-size: 1rem;
      line-height: 1;
    }

    .search-close:focus-visible {
      outline: 3px solid var(--focus-ring);
      outline-offset: 1px;
    }

    .search-hit {
      background: #ffe7a3;
      color: inherit;
      border-radius: 2px;
      padding: 0;
    }

    .search-hit.is-active {
      background: #ffc94f;
    }

    .slide h1,
    .slide h2,
    .slide h3 {
      margin-top: 0;
      line-height: 1.12;
      letter-spacing: -0.01em;
    }

    .slide h1 {
      font-size: clamp(2rem, 3vw, 3.2rem);
    }

    .slide h2 {
      font-size: clamp(1.6rem, 2.4vw, 2.4rem);
    }

    .slide h3 {
      font-size: clamp(1.3rem, 1.8vw, 1.7rem);
    }

    .slide p,
    .slide li,
    .slide blockquote,
    .slide pre {
      margin: 0 0 0.8em;
    }

    .slide ul,
    .slide ol {
      padding-left: 1.4em;
    }

    .slide code {
      background: #ebf1f8;
      border-radius: 6px;
      padding: 0.08em 0.34em;
      font-size: 0.9em;
    }

    .slide pre {
      background: #edf3fa;
      border: 1px solid #d7e1ef;
      border-radius: 10px;
      padding: 0.9em;
      overflow: auto;
    }

    .slide pre code {
      background: transparent;
      padding: 0;
    }

    .slide blockquote {
      margin-left: 0;
      padding-left: 0.9em;
      border-left: 4px solid #cfe2fa;
      color: #3e4c64;
    }

    .slide table {
      width: 100%;
      border-collapse: collapse;
      margin: 0 0 0.8em;
    }

    .slide th,
    .slide td {
      border: 1px solid #d7e1ef;
      padding: 8px 10px;
      text-align: left;
      vertical-align: top;
    }

    .slide thead th {
      background: #f3f7fd;
      font-weight: 700;
    }

    .slide mark {
      background: #fff1bf;
      color: inherit;
      padding: 0 0.12em;
      border-radius: 4px;
    }

    .empty {
      display: grid;
      place-items: center;
      height: 100%;
      text-align: center;
      color: var(--muted);
      font-size: clamp(1rem, 1.2vw, 1.2rem);
    }

    .empty strong {
      display: block;
      font-size: clamp(1.2rem, 2vw, 1.6rem);
      color: var(--text);
      margin-bottom: 8px;
    }

    .empty .upload-cta {
      margin-top: 14px;
    }

    .embed-warning {
      margin-top: 14px;
      padding: 10px 12px;
      border: 1px solid #f2d6a8;
      border-radius: 10px;
      background: #fff6e7;
      color: #7a5a20;
      font-size: 0.9rem;
    }

    .media-warning {
      margin-top: 8px;
      padding: 8px 10px;
      border: 1px solid #e8d3a1;
      border-radius: 8px;
      background: #fff8ea;
      color: #6f5421;
      font-size: 0.85rem;
    }

    .callout {
      margin: 0 0 0.9em;
      border: 1px solid #d6e4f6;
      border-left-width: 5px;
      border-radius: 10px;
      background: #f7fbff;
      padding: 0.7em 0.9em 0.75em;
    }

    .callout-title {
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 700;
      margin-bottom: 0.35em;
      text-transform: capitalize;
      color: #25456c;
    }

    .callout-title::before {
      content: "";
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: currentColor;
      opacity: 0.8;
    }

    .callout.is-collapsed > :not(.callout-title) {
      display: none;
    }

    .callout.is-foldable .callout-title {
      cursor: pointer;
      user-select: none;
    }

    .callout.callout-note {
      border-color: #cfe0f9;
      background: #f4f9ff;
    }

    .callout.callout-tip {
      border-color: #cae9d4;
      background: #f3fbf6;
    }

    .callout.callout-success {
      border-color: #bfe7c7;
      background: #eefaf1;
    }

    .callout.callout-warning {
      border-color: #f3dfb2;
      background: #fff9ed;
    }

    .callout.callout-danger {
      border-color: #f1c6cb;
      background: #fff3f4;
    }

    .callout.callout-info {
      border-color: #cde6f2;
      background: #f3fbff;
    }

    .callout.callout-question {
      border-color: #d8cef2;
      background: #f7f3ff;
    }

    .callout.callout-example {
      border-color: #e3d3c0;
      background: #fbf6ef;
    }

    .callout.callout-quote {
      border-color: #d7dbe3;
      background: #f8f9fc;
    }

    .slide .md-tag {
      display: inline-block;
      padding: 0 0.35em;
      border-radius: 999px;
      background: #eaf3ff;
      color: #1c5fa0;
      font-size: 0.9em;
      line-height: 1.4;
    }

    .slide .internal-anchor {
      text-decoration-thickness: 1px;
    }

    a:focus-visible {
      outline: 2px solid var(--focus-ring);
      outline-offset: 2px;
      border-radius: 3px;
    }

    .slide .footnotes {
      margin-top: 1.4em;
      padding-top: 0.8em;
      border-top: 1px solid #d7e1ef;
      color: #43526c;
      font-size: 0.9em;
    }

    .slide .footnotes ol {
      margin: 0.4em 0 0;
      padding-left: 1.2em;
    }

    .slide .footnote-ref a {
      text-decoration: none;
      font-size: 0.85em;
    }

    .slide .mermaid {
      margin: 0 0 0.8em;
      overflow: auto;
    }

    #fileInput {
      display: none;
    }

    @media (prefers-reduced-motion: reduce) {
      *, *::before, *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
        scroll-behavior: auto !important;
      }

      .upload-cta:hover,
      .map-toggle:hover:not(:disabled),
      .search-toggle:hover,
      .arrows-toggle:hover,
      .station:hover,
      .station.active {
        transform: none !important;
      }
    }
  </style>
</head>
<body>
  <a class="skip-link" href="#slide">Skip to slide content</a>
  <main class="app">
    <input id="fileInput" type="file" accept=".md,.markdown,text/markdown,text/plain" />
    <article id="slide" class="slide" aria-live="polite" aria-atomic="true" role="region" aria-label="Slide content" tabindex="-1"></article>
    <nav id="trainMap" class="train-map" aria-label="Slide train map"></nav>
  </main>
  <button id="mapToggle" class="map-toggle" type="button" aria-label="Show or hide route line" title="Show or hide route line" aria-controls="trainMap" aria-expanded="false">
    <span class="material-symbols-outlined" aria-hidden="true">route</span>
  </button>
  <button id="arrowsToggle" class="arrows-toggle" type="button" aria-label="Show or hide navigation arrows" title="Show or hide navigation arrows" aria-controls="prevArrow nextArrow" aria-expanded="false">
    <span class="material-symbols-outlined" aria-hidden="true">swap_horiz</span>
  </button>
  <button id="searchToggle" class="search-toggle" type="button" aria-label="Search slides" title="Search slides" aria-controls="searchPanel" aria-expanded="false">
    <span class="material-symbols-outlined" aria-hidden="true">search</span>
  </button>
  <button id="prevArrow" class="nav-arrow left" type="button" aria-label="Previous slide" hidden>
    <span class="material-symbols-outlined" aria-hidden="true">chevron_left</span>
  </button>
  <button id="nextArrow" class="nav-arrow right" type="button" aria-label="Next slide" hidden>
    <span class="material-symbols-outlined" aria-hidden="true">chevron_right</span>
  </button>
  <section id="searchPanel" class="search-panel" role="search" aria-label="Slide search" hidden>
    <label class="sr-only" for="searchInput">Search slides</label>
    <input id="searchInput" class="search-input" type="text" autocomplete="off" placeholder="Search slides..." />
    <div id="searchCount" class="search-count" aria-live="polite">0 / 0</div>
    <button id="searchPrev" class="search-nav" type="button" aria-label="Previous match">↑</button>
    <button id="searchNext" class="search-nav" type="button" aria-label="Next match">↓</button>
    <button id="searchClose" class="search-close" type="button" aria-label="Close search">✕</button>
  </section>
  <div id="srStatus" class="sr-only" aria-live="polite" aria-atomic="true"></div>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,600,0,0" />
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js"></script>
  <script>
    const state = {
      slides: [],
      index: 0,
      showTrainMap: false,
      frontmatter: {},
      search: {
        query: "",
        results: [],
        activeIndex: -1,
        panelOpen: false
      },
      showNavArrows: false
    };

    const appEl = document.querySelector(".app");
    const slideEl = document.getElementById("slide");
    const fileInputEl = document.getElementById("fileInput");
    const trainMapEl = document.getElementById("trainMap");
    const mapToggleEl = document.getElementById("mapToggle");
    const arrowsToggleEl = document.getElementById("arrowsToggle");
    const searchToggleEl = document.getElementById("searchToggle");
    const searchPanelEl = document.getElementById("searchPanel");
    const searchInputEl = document.getElementById("searchInput");
    const searchCountEl = document.getElementById("searchCount");
    const searchPrevEl = document.getElementById("searchPrev");
    const searchNextEl = document.getElementById("searchNext");
    const searchCloseEl = document.getElementById("searchClose");
    const prevArrowEl = document.getElementById("prevArrow");
    const nextArrowEl = document.getElementById("nextArrow");
    const srStatusEl = document.getElementById("srStatus");

    function announceStatus(message) {
      if (!srStatusEl) {
        return;
      }
      srStatusEl.textContent = "";
      window.requestAnimationFrame(() => {
        srStatusEl.textContent = message;
      });
    }

    function escapeHtml(input) {
      return input
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;");
    }

    if (window.marked) {
      window.marked.setOptions({
        gfm: true,
        breaks: false,
        headerIds: false,
        mangle: false
      });
    }

    if (window.mermaid) {
      window.mermaid.initialize({
        startOnLoad: false,
        securityLevel: "loose",
        theme: "default"
      });
    }

    function slugify(value) {
      return String(value || "")
        .toLowerCase()
        .trim()
        .replace(/[^\w\s-]/g, "")
        .replace(/\s+/g, "-");
    }

    function extractFrontmatter(markdown) {
      const normalized = markdown.replace(/\r\n?/g, "\n");
      if (!normalized.startsWith("---\n")) {
        return { content: normalized, metadata: {} };
      }

      const endIndex = normalized.indexOf("\n---\n", 4);
      if (endIndex === -1) {
        return { content: normalized, metadata: {} };
      }

      const frontmatterText = normalized.slice(4, endIndex).trim();
      const body = normalized.slice(endIndex + 5);
      const metadata = {};
      frontmatterText.split("\n").forEach((line) => {
        const match = line.match(/^([A-Za-z0-9_-]+)\s*:\s*(.*)$/);
        if (match) {
          metadata[match[1]] = match[2].trim();
        }
      });
      return { content: body, metadata };
    }

    function markdownToHtml(markdown) {
      const normalized = markdown.replace(/\r\n?/g, "\n");
      if (window.marked && typeof window.marked.parse === "function") {
        return window.marked.parse(normalized);
      }
      return `<pre>${escapeHtml(normalized)}</pre>`;
    }

    function transformFootnotes(markdown) {
      const lines = markdown.split("\n");
      const definitions = {};
      const skip = new Set();
      let inCode = false;

      for (let i = 0; i < lines.length; i += 1) {
        const line = lines[i];
        if (/^```/.test(line.trim())) {
          inCode = !inCode;
          continue;
        }
        if (inCode) {
          continue;
        }

        const match = line.match(/^\[\^([^\]]+)\]:\s*(.*)$/);
        if (!match) {
          continue;
        }

        const id = match[1];
        const parts = [match[2]];
        skip.add(i);
        let j = i + 1;
        while (j < lines.length && (/^\s{2,}/.test(lines[j]) || /^\t/.test(lines[j]))) {
          parts.push(lines[j].replace(/^\s{1,4}/, ""));
          skip.add(j);
          j += 1;
        }
        definitions[id] = parts.join("\n").trim();
        i = j - 1;
      }

      const body = lines.filter((_, idx) => !skip.has(idx)).join("\n");
      const usedOrder = [];
      const textWithRefs = body.replace(/\[\^([^\]]+)\]/g, (full, id) => {
        if (!definitions[id]) {
          return full;
        }
        if (!usedOrder.includes(id)) {
          usedOrder.push(id);
        }
        const number = usedOrder.indexOf(id) + 1;
        const slug = slugify(id);
        return `<sup class="footnote-ref"><a href="#fn-${slug}" id="fnref-${slug}">${number}</a></sup>`;
      });

      if (!usedOrder.length) {
        return textWithRefs;
      }

      const items = usedOrder.map((id) => {
        const slug = slugify(id);
        const raw = definitions[id] || "";
        const rendered = window.marked && typeof window.marked.parseInline === "function"
          ? window.marked.parseInline(raw)
          : escapeHtml(raw);
        return `<li id="fn-${slug}">${rendered} <a href="#fnref-${slug}" aria-label="Back to reference">↩</a></li>`;
      }).join("");

      return `${textWithRefs}\n\n<section class="footnotes"><ol>${items}</ol></section>`;
    }

    function applyObsidianSyntax(markdown) {
      let text = markdown.replace(/\r\n?/g, "\n");

      // Obsidian comments
      text = text.replace(/%%[\s\S]*?%%/g, "");

      // Internal anchors: [[Note#Heading]] or [[#Heading]] (+ optional alias)
      text = text.replace(/\[\[(?:([^#\]|]+))?#([^\]|]+)(?:\|([^\]]+))?\]\]/g, (_, rawNote, rawHeading, rawAlias) => {
        const note = String(rawNote || "").trim();
        const heading = String(rawHeading || "").trim();
        const alias = String(rawAlias || heading).trim();
        const anchor = slugify(heading);
        const noteAttr = note ? ` data-note="${note.replace(/"/g, "&quot;")}"` : "";
        return `<a class="internal-anchor" href="#${anchor}"${noteAttr}>${alias}</a>`;
      });

      // ==highlight==
      text = text.replace(/==([^\n=][^=\n]*?)==/g, "<mark>$1</mark>");

      // x^2^ and H~2~ style markers
      text = text.replace(/\^([^\^\s][^\^]*?)\^/g, "<sup>$1</sup>");
      text = text.replace(/~([^~\s][^~]*?)~/g, "<sub>$1</sub>");

      return transformFootnotes(text);
    }

    function parseSlides(markdown) {
      const { content, metadata } = extractFrontmatter(markdown);
      state.frontmatter = metadata;

      const rawSlides = content
        .split(/^===\s*$/m)
        .map((chunk) => chunk.trim())
        .filter(Boolean);

      return rawSlides.map((raw) => {
        const noteSeparator = raw.split(/^--\s*$/m);
        const content = noteSeparator[0].trim();
        const enhanced = applyObsidianSyntax(content);
        return {
          content,
          notes: noteSeparator.slice(1).join("\n").trim(),
          html: markdownToHtml(enhanced)
        };
      });
    }

    function assignHeadingIds() {
      const contentRoot = slideEl.querySelector(".slide-content");
      if (!contentRoot) {
        return;
      }
      const seen = new Map();
      contentRoot.querySelectorAll("h1, h2, h3, h4, h5, h6").forEach((heading) => {
        if (heading.id) {
          return;
        }
        const base = slugify(heading.textContent || "section") || "section";
        const count = seen.get(base) || 0;
        seen.set(base, count + 1);
        heading.id = count ? `${base}-${count + 1}` : base;
      });
    }

    function configureEmbeds() {
      const contentRoot = slideEl.querySelector(".slide-content");
      if (!contentRoot) {
        return;
      }

      const iframes = Array.from(contentRoot.querySelectorAll("iframe"));
      const isFileProtocol = window.location.protocol === "file:";
      let hasYouTubeEmbed = false;

      iframes.forEach((iframe) => {
        const rawSrc = iframe.getAttribute("src") || "";
        if (!rawSrc) {
          return;
        }

        let url;
        try {
          url = new URL(rawSrc, window.location.href);
        } catch {
          return;
        }

        const host = url.hostname.toLowerCase();
        const isYouTube =
          host.includes("youtube.com") ||
          host.includes("youtu.be") ||
          host.includes("youtube-nocookie.com");

        if (!isYouTube) {
          return;
        }

        hasYouTubeEmbed = true;
        iframe.referrerPolicy = "origin-when-cross-origin";
        iframe.setAttribute("allowfullscreen", "");

        if (window.location.protocol.startsWith("http") && !url.searchParams.get("origin")) {
          url.searchParams.set("origin", window.location.origin);
        }

        if (host.includes("youtube.com") && !host.includes("youtube-nocookie.com")) {
          url.hostname = "www.youtube-nocookie.com";
        }

        iframe.src = url.toString();
      });

      if (isFileProtocol && hasYouTubeEmbed) {
        const warning = document.createElement("div");
        warning.className = "embed-warning";
        warning.textContent = "YouTube embed may fail in file:// mode (Error 153). Serve this app over http://localhost to enable it.";
        contentRoot.appendChild(warning);
      }
    }

    function enhanceMediaAccessibility() {
      const contentRoot = slideEl.querySelector(".slide-content");
      if (!contentRoot) {
        return;
      }

      const iframes = Array.from(contentRoot.querySelectorAll("iframe"));
      iframes.forEach((iframe, index) => {
        if (!iframe.getAttribute("title")) {
          iframe.setAttribute("title", `Embedded media ${index + 1}`);
        }
      });

      const videos = Array.from(contentRoot.querySelectorAll("video"));
      videos.forEach((video, index) => {
        video.setAttribute("controls", "");
        if (!video.getAttribute("aria-label") && !video.getAttribute("title")) {
          video.setAttribute("aria-label", `Video ${index + 1}`);
        }

        const hasTrack = video.querySelector("track[kind='captions'], track[kind='subtitles']");
        if (!hasTrack) {
          const warning = document.createElement("div");
          warning.className = "media-warning";
          warning.textContent = "No captions or subtitles track detected for this video.";
          video.insertAdjacentElement("afterend", warning);
        }
      });
    }

    function enhanceCallouts() {
      const contentRoot = slideEl.querySelector(".slide-content");
      if (!contentRoot) {
        return;
      }

      const calloutTypeMap = {
        abstract: "info",
        summary: "info",
        tldr: "info",
        info: "info",
        todo: "note",
        note: "note",
        hint: "tip",
        important: "tip",
        tip: "tip",
        success: "success",
        check: "success",
        done: "success",
        question: "question",
        help: "question",
        faq: "question",
        warning: "warning",
        caution: "warning",
        attention: "warning",
        failure: "danger",
        fail: "danger",
        missing: "danger",
        danger: "danger",
        error: "danger",
        bug: "danger",
        example: "example",
        quote: "quote"
      };

      const blockquotes = Array.from(contentRoot.querySelectorAll("blockquote"));
      blockquotes.forEach((blockquote) => {
        const firstLineNode = blockquote.querySelector("p, div");
        if (!firstLineNode) {
          return;
        }

        const firstLineText = String(firstLineNode.textContent || "")
          .split(/\r?\n/)[0]
          .trim();
        const match = firstLineText.match(/^\s*\[!([A-Za-z-]+)\]([+-])?\s*(.*)$/i);
        if (!match) {
          return;
        }

        const rawType = match[1].toLowerCase();
        const type = calloutTypeMap[rawType] || rawType;
        const fold = match[2] || "";
        const customTitle = (match[3] || "").trim();
        const titleText = customTitle || type;

        blockquote.classList.add("callout", `callout-${type}`);
        if (fold) {
          blockquote.classList.add("is-foldable");
          if (fold === "-") {
            blockquote.classList.add("is-collapsed");
          }
        }

        const title = document.createElement("div");
        title.className = "callout-title";
        title.textContent = titleText;

        if (blockquote.firstElementChild === firstLineNode) {
          blockquote.insertBefore(title, firstLineNode);
        } else {
          blockquote.prepend(title);
        }

        const firstHtml = firstLineNode.innerHTML.replace(/^\s*\[![A-Za-z-]+\][+-]?\s*/i, "");
        if (firstHtml.trim()) {
          firstLineNode.innerHTML = firstHtml;
        } else {
          firstLineNode.remove();
        }

        if (fold) {
          title.setAttribute("tabindex", "0");
          title.setAttribute("role", "button");
          title.setAttribute("aria-expanded", String(!blockquote.classList.contains("is-collapsed")));
          title.addEventListener("click", () => {
            blockquote.classList.toggle("is-collapsed");
            title.setAttribute("aria-expanded", String(!blockquote.classList.contains("is-collapsed")));
          });
          title.addEventListener("keydown", (event) => {
            if (event.key === "Enter" || event.key === " ") {
              event.preventDefault();
              blockquote.classList.toggle("is-collapsed");
              title.setAttribute("aria-expanded", String(!blockquote.classList.contains("is-collapsed")));
            }
          });
        }
      });
    }

    function renderMath() {
      const contentRoot = slideEl.querySelector(".slide-content");
      if (!contentRoot || typeof window.renderMathInElement !== "function") {
        return;
      }

      window.renderMathInElement(contentRoot, {
        delimiters: [
          { left: "$$", right: "$$", display: true },
          { left: "$", right: "$", display: false }
        ],
        throwOnError: false
      });
    }

    function clearSearchHighlights() {
      const contentRoot = slideEl.querySelector(".slide-content");
      if (!contentRoot) {
        return;
      }
      const marks = Array.from(contentRoot.querySelectorAll("mark.search-hit"));
      marks.forEach((mark) => {
        const parent = mark.parentNode;
        if (!parent) {
          return;
        }
        parent.replaceChild(document.createTextNode(mark.textContent || ""), mark);
        parent.normalize();
      });
    }

    function updateSearchCount() {
      if (!searchCountEl) {
        return;
      }
      const total = state.search.results.length;
      if (!state.search.query.trim() || total === 0 || state.search.activeIndex < 0) {
        searchCountEl.textContent = "0 / 0";
        return;
      }
      searchCountEl.textContent = `${state.search.activeIndex + 1} / ${total}`;
    }

    function applySearchHighlights() {
      clearSearchHighlights();

      const query = state.search.query.trim();
      if (!query) {
        updateSearchCount();
        return;
      }

      const contentRoot = slideEl.querySelector(".slide-content");
      if (!contentRoot) {
        updateSearchCount();
        return;
      }

      const active = state.search.results[state.search.activeIndex];
      const activeOccurrence = active && active.slideIndex === state.index ? active.occurrence : -1;
      const qLower = query.toLowerCase();
      let occurrence = 0;
      let activeMark = null;

      const walker = document.createTreeWalker(contentRoot, NodeFilter.SHOW_TEXT);
      const targets = [];
      while (walker.nextNode()) {
        const node = walker.currentNode;
        const parent = node.parentElement;
        if (!parent) {
          continue;
        }
        if (parent.closest("script, style, pre, code, .katex, .mermaid, svg, math, textarea")) {
          continue;
        }
        if ((node.nodeValue || "").toLowerCase().includes(qLower)) {
          targets.push(node);
        }
      }

      targets.forEach((node) => {
        const text = node.nodeValue || "";
        const lower = text.toLowerCase();
        let cursor = 0;
        let idx = lower.indexOf(qLower, cursor);
        if (idx === -1) {
          return;
        }

        const frag = document.createDocumentFragment();
        while (idx !== -1) {
          if (idx > cursor) {
            frag.appendChild(document.createTextNode(text.slice(cursor, idx)));
          }
          const mark = document.createElement("mark");
          mark.className = "search-hit";
          mark.textContent = text.slice(idx, idx + query.length);
          occurrence += 1;
          if (occurrence === activeOccurrence) {
            mark.classList.add("is-active");
            activeMark = mark;
          }
          frag.appendChild(mark);
          cursor = idx + query.length;
          idx = lower.indexOf(qLower, cursor);
        }

        if (cursor < text.length) {
          frag.appendChild(document.createTextNode(text.slice(cursor)));
        }
        node.parentNode.replaceChild(frag, node);
      });

      if (activeMark) {
        activeMark.scrollIntoView({ block: "nearest", inline: "nearest" });
      }
      updateSearchCount();
    }

    function setSearchPanelOpen(open) {
      state.search.panelOpen = open;
      searchPanelEl.hidden = !open;
      searchToggleEl.setAttribute("aria-expanded", String(open));
      if (open) {
        searchInputEl.focus();
        searchInputEl.select();
      }
    }

    function toggleSearchPanel() {
      setSearchPanelOpen(!state.search.panelOpen);
    }

    function rebuildSearchResults() {
      const query = state.search.query.trim().toLowerCase();
      state.search.results = [];
      state.search.activeIndex = -1;

      if (!query || !state.slides.length) {
        applySearchHighlights();
        return;
      }

      state.slides.forEach((slide, slideIndex) => {
        const text = String(slide.content || "").toLowerCase();
        let from = 0;
        let occurrence = 0;
        let at = text.indexOf(query, from);
        while (at !== -1) {
          occurrence += 1;
          state.search.results.push({ slideIndex, occurrence });
          from = at + query.length;
          at = text.indexOf(query, from);
        }
      });

      if (!state.search.results.length) {
        applySearchHighlights();
        announceStatus("No search results.");
        return;
      }

      const currentSlideResult = state.search.results.findIndex((item) => item.slideIndex === state.index);
      state.search.activeIndex = currentSlideResult >= 0 ? currentSlideResult : 0;
      goToSearchResult(state.search.activeIndex, false);
    }

    function goToSearchResult(index, announce = true) {
      const total = state.search.results.length;
      if (!total) {
        state.search.activeIndex = -1;
        updateSearchCount();
        return;
      }

      const nextIndex = ((index % total) + total) % total;
      state.search.activeIndex = nextIndex;
      const target = state.search.results[nextIndex];
      if (!target) {
        updateSearchCount();
        return;
      }

      if (state.index !== target.slideIndex) {
        state.index = target.slideIndex;
        renderSlide();
      } else {
        applySearchHighlights();
      }

      if (announce) {
        announceStatus(`Match ${nextIndex + 1} of ${total}, slide ${target.slideIndex + 1}.`);
      }
    }

    function goToNextSearchResult() {
      goToSearchResult(state.search.activeIndex + 1);
    }

    function goToPreviousSearchResult() {
      goToSearchResult(state.search.activeIndex - 1);
    }

    function enhanceTags() {
      const contentRoot = slideEl.querySelector(".slide-content");
      if (!contentRoot) {
        return;
      }

      const walker = document.createTreeWalker(contentRoot, NodeFilter.SHOW_TEXT);
      const targets = [];
      while (walker.nextNode()) {
        const node = walker.currentNode;
        const parent = node.parentElement;
        if (!parent) {
          continue;
        }
        if (parent.closest("pre, code, a, script, style, .katex, .mermaid")) {
          continue;
        }
        if (/(^|\s)#[A-Za-z][\w/-]*/.test(node.textContent || "")) {
          targets.push(node);
        }
      }

      targets.forEach((node) => {
        const text = node.textContent || "";
        const frag = document.createDocumentFragment();
        const regex = /(^|\s)(#[A-Za-z][\w/-]*)/g;
        let last = 0;
        let match;
        while ((match = regex.exec(text)) !== null) {
          const index = match.index;
          const leading = match[1] || "";
          const tag = match[2];
          const preText = text.slice(last, index);
          if (preText) {
            frag.appendChild(document.createTextNode(preText));
          }
          if (leading) {
            frag.appendChild(document.createTextNode(leading));
          }
          const span = document.createElement("span");
          span.className = "md-tag";
          span.textContent = tag;
          frag.appendChild(span);
          last = index + leading.length + tag.length;
        }
        const tail = text.slice(last);
        if (tail) {
          frag.appendChild(document.createTextNode(tail));
        }
        node.parentNode.replaceChild(frag, node);
      });
    }

    async function renderMermaid() {
      const contentRoot = slideEl.querySelector(".slide-content");
      if (!contentRoot || !window.mermaid) {
        return;
      }

      const blocks = Array.from(contentRoot.querySelectorAll("pre > code.language-mermaid"));
      blocks.forEach((code, idx) => {
        const pre = code.parentElement;
        if (!pre) {
          return;
        }
        const container = document.createElement("div");
        container.className = "mermaid";
        container.id = `mermaid-${state.index}-${idx}`;
        container.textContent = code.textContent || "";
        pre.replaceWith(container);
      });

      if (blocks.length) {
        try {
          await window.mermaid.run({ querySelector: ".mermaid" });
        } catch {
          // Keep raw text already visible inside .mermaid container.
        }
        updateSlideAlignment();
      }
    }

    function renderSlide() {
      if (!state.slides.length) {
        slideEl.innerHTML = `
          <div class="empty">
            <div>
              <strong>Upload a markdown file</strong>
              <div>Use <code>===</code> for slides and <code>--</code> for speaker notes.</div>
              <button class="upload-cta" type="button" data-action="upload" aria-label="Import markdown file">
                <svg viewBox="0 0 24 24" aria-hidden="true">
                  <path d="M14 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V8zm-2 18H8v-2h4zm2-4H8v-2h6zm0-4H8v-2h6zm-1-3V3.5L18.5 9z"/>
                </svg>
                Import .md File
              </button>
            </div>
          </div>
        `;
        renderTrainMap();
        renderNavArrows();
        announceStatus("No slides loaded. Upload a markdown file.");
        return;
      }

      slideEl.innerHTML = `
        <div class="slide-center">
          <div class="slide-content">${state.slides[state.index].html || "<p></p>"}</div>
        </div>
      `;
      assignHeadingIds();
      configureEmbeds();
      enhanceMediaAccessibility();
      enhanceCallouts();
      enhanceTags();
      renderMath();
      renderMermaid();
      applySearchHighlights();
      updateSlideAlignment();
      slideEl.scrollTop = 0;
      renderTrainMap();
      renderNavArrows();
      announceStatus(`Slide ${state.index + 1} of ${state.slides.length}`);
    }

    function updateSlideAlignment() {
      const centerEl = slideEl.querySelector(".slide-center");
      const contentEl = slideEl.querySelector(".slide-content");
      if (!centerEl || !contentEl) {
        slideEl.classList.remove("is-tall");
        return;
      }

      const styles = window.getComputedStyle(centerEl);
      const padTop = parseFloat(styles.paddingTop) || 0;
      const padBottom = parseFloat(styles.paddingBottom) || 0;
      const availableHeight = slideEl.clientHeight - padTop - padBottom;
      const contentHeight = contentEl.offsetHeight;
      slideEl.classList.toggle("is-tall", contentHeight > availableHeight);
    }

    function goNext() {
      if (state.index < state.slides.length - 1) {
        state.index += 1;
        renderSlide();
      }
    }

    function goPrev() {
      if (state.index > 0) {
        state.index -= 1;
        renderSlide();
      }
    }

    function renderNavArrows() {
      const hasSlides = state.slides.length > 0;
      const visible = state.showNavArrows && hasSlides;
      prevArrowEl.hidden = !visible;
      nextArrowEl.hidden = !visible;
      arrowsToggleEl.setAttribute("aria-expanded", String(visible));
      arrowsToggleEl.disabled = !hasSlides;
      if (!visible) {
        return;
      }
      prevArrowEl.disabled = state.index <= 0;
      nextArrowEl.disabled = state.index >= state.slides.length - 1;
    }

    function renderTrainMap() {
      trainMapEl.innerHTML = "";

      if (!state.slides.length) {
        state.showTrainMap = false;
        appEl.classList.remove("train-visible");
        mapToggleEl.disabled = true;
        mapToggleEl.setAttribute("aria-pressed", "false");
        mapToggleEl.setAttribute("aria-expanded", "false");
        trainMapEl.setAttribute("aria-hidden", "true");
        return;
      }

      mapToggleEl.disabled = false;
      mapToggleEl.setAttribute("aria-pressed", String(state.showTrainMap));
      mapToggleEl.setAttribute("aria-expanded", String(state.showTrainMap));
      trainMapEl.setAttribute("aria-hidden", String(!state.showTrainMap));
      appEl.classList.toggle("train-visible", state.showTrainMap);
      if (!state.showTrainMap) {
        updateSlideAlignment();
        return;
      }

      const track = document.createElement("div");
      track.className = "train-track";
      trainMapEl.appendChild(track);

      const progress = document.createElement("div");
      progress.className = "train-progress";
      const progressRatio = state.slides.length > 1 ? state.index / (state.slides.length - 1) : 0;
      progress.style.width = `calc((100% - 48px) * ${progressRatio})`;
      trainMapEl.appendChild(progress);

      const stationList = document.createElement("div");
      stationList.className = "station-list";

      state.slides.forEach((_, idx) => {
        const step = document.createElement("div");
        step.className = "station-step";

        const station = document.createElement("button");
        station.type = "button";
        station.className = "station";
        if (idx < state.index) {
          station.classList.add("past");
        }
        if (idx === state.index) {
          station.classList.add("active");
          station.setAttribute("aria-current", "step");
        }
        station.setAttribute("aria-label", `Go to slide ${idx + 1}`);
        station.title = `Slide ${idx + 1}`;
        station.addEventListener("click", () => {
          state.index = idx;
          renderSlide();
        });

        const num = document.createElement("span");
        num.className = "station-num";
        num.textContent = String(idx + 1);

        step.appendChild(station);
        step.appendChild(num);
        stationList.appendChild(step);
      });

      trainMapEl.appendChild(stationList);
      updateSlideAlignment();
    }

    function handleUpload(event) {
      const file = event.target.files?.[0];
      if (!file) {
        return;
      }

      const reader = new FileReader();
      reader.onload = () => {
        const text = String(reader.result || "");
        state.slides = parseSlides(text);
        state.index = 0;
        if (state.search.query.trim()) {
          rebuildSearchResults();
        }
        renderSlide();
      };
      reader.readAsText(file);
      event.target.value = "";
    }

    slideEl.addEventListener("click", (event) => {
      const target = event.target.closest("[data-action='upload']");
      if (target) {
        fileInputEl.click();
      }
    });
    fileInputEl.addEventListener("change", handleUpload);
    mapToggleEl.addEventListener("click", () => {
      if (!state.slides.length) {
        return;
      }
      state.showTrainMap = !state.showTrainMap;
      renderTrainMap();
      announceStatus(state.showTrainMap ? "Route map shown." : "Route map hidden.");
    });
    arrowsToggleEl.addEventListener("click", () => {
      if (!state.slides.length) {
        return;
      }
      state.showNavArrows = !state.showNavArrows;
      renderNavArrows();
      announceStatus(state.showNavArrows ? "Navigation arrows shown." : "Navigation arrows hidden.");
    });
    prevArrowEl.addEventListener("click", goPrev);
    nextArrowEl.addEventListener("click", goNext);
    searchToggleEl.addEventListener("click", () => {
      toggleSearchPanel();
    });
    searchCloseEl.addEventListener("click", () => {
      setSearchPanelOpen(false);
    });
    searchInputEl.addEventListener("input", () => {
      state.search.query = searchInputEl.value;
      rebuildSearchResults();
    });
    searchInputEl.addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        event.preventDefault();
        if (event.shiftKey) {
          goToPreviousSearchResult();
        } else {
          goToNextSearchResult();
        }
      }
      if (event.key === "Escape") {
        event.preventDefault();
        setSearchPanelOpen(false);
      }
    });
    searchNextEl.addEventListener("click", goToNextSearchResult);
    searchPrevEl.addEventListener("click", goToPreviousSearchResult);

    function isInteractiveTarget(element) {
      if (!(element instanceof HTMLElement)) {
        return false;
      }
      return Boolean(
        element.closest("input, textarea, select, button, a, [contenteditable='true'], video, iframe")
      );
    }

    document.addEventListener("keydown", (event) => {
      if ((event.ctrlKey || event.metaKey) && event.key.toLowerCase() === "f") {
        event.preventDefault();
        if (!state.search.panelOpen) {
          setSearchPanelOpen(true);
        } else {
          searchInputEl.focus();
          searchInputEl.select();
        }
        return;
      }

      if (isInteractiveTarget(event.target)) {
        return;
      }

      if (event.key === "ArrowRight" || event.key === "PageDown" || event.key === " ") {
        event.preventDefault();
        goNext();
      }
      if (event.key === "ArrowLeft" || event.key === "PageUp") {
        event.preventDefault();
        goPrev();
      }
      if (event.key.toLowerCase() === "m" && event.altKey && state.slides.length) {
        state.showTrainMap = !state.showTrainMap;
        renderTrainMap();
        announceStatus(state.showTrainMap ? "Route map shown." : "Route map hidden.");
      }
      if (event.key === "Escape" && state.search.panelOpen) {
        setSearchPanelOpen(false);
      }
    });

    window.addEventListener("resize", updateSlideAlignment);

    renderSlide();
  </script>
</body>
</html>
